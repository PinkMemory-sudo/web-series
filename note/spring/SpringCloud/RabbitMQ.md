

# Features

* Asynchronous Messaging







消息队列：

消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回

消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列



MQ典型应用场景：

- 异步处理。把消息放入消息中间件中，等到需要的时候再去处理。
- 流量削峰
- 日志处理
- 应用解耦，使用MQ发布订阅模式，需要就订阅，不需要就取消订阅



***几个重要概念：***

* Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列，如果路由不到，或者返回给生产者，或者直接丢弃。

* Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
* Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
* RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。
* Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
* Connection：连接，应用程序与Server的网络连接，TCP连接。
* Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。



***为什么使用信道***

一个程序中可以有多个线程来生产或消费消息，如果是直接建立多个connection，代价是比较昂贵的，如果遇到使用高峰，性能瓶颈也随之显现，RabbitMQ 采用 TCP 连接复用的方式，不仅可以减少性能开销，同时也便于管理。



![AMQP协议模型](/Users/chenguanlin/Documents/note/0img/AMAP模型.png)

由生产者，消费者，服务端组成

生产者先连接到server，开启信道，配置相关属性绑定Exchange和Queue，消费者同理。

接着生产者生产消息，将消息发送到虚拟主机，虚机主机中的Exchange根据路由键选择路由，将消息添加到对应的Queue。

订阅了该消息队列的消费者开始消费。

最后关闭信道和连接。



RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种。

direct：



高级特性

过期时间（TTL）

一条消息在队列中的最大存活时间，单位是毫秒

RabbitMQ支持设置消息的过期时间，在消息发送的时候可以进行指定，每条消息的过期时间可以不同。

RabbitMQ支持设置队列的过期时间，从消息入队列开始计算，直到超过了队列的超时时间配置，那么消息会变成死信，自动清除。

如果两种方式一起使用，则过期时间以两者中较小的那个数值为准。



消息确认

为了保证消息从队列可靠地到达消费者，RabbitMQ提供了消息确认机制。消费者订阅队列的时候，可以指定autoAck参数，当autoAck为true的时候，RabbitMQ采用自动确认模式，RabbitMQ自动把发送出去的消息设置为确认，然后从内存或者硬盘中删除，而不管消费者是否真正消费到了这些消息。当autoAck为false的时候，RabbitMQ会等待消费者回复的确认信号，收到确认信号之后才从内存或者磁盘中删除消息。

消息确认机制是RabbitMQ消息可靠性投递的基础，只要设置autoAck参数为false，消费者就有足够的时间处理消息，不用担心处理消息的过程中消费者进程挂掉后消息丢失的问题。



持久化

消息持久化来保证消息的可靠性，持久化可以防止在异常情况下丢失数据。RabbitMQ的持久化分为三个部分：交换器持久化、队列持久化和消息的持久化。



死信队列



延迟队列





